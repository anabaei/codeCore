
## Simple form 
https://github.com/plataformatec/simple_form
common propblem in terminal
```ruby
pg_ctl -D /usr/local/var/postgres -l logfile start
```

```ruby
gem 'simple_form'
```
```ruby
rails g simple_fomr:install --bootstrap
```
* In simple_form we dont need to have labels for each input, also in `config/initializers/simple_form.rb` is default configuration. Then the entire code would be as simple as below.
```ruby
<%= f.input :ttile %>
<%= f.button :submit %>
```
#### override simple form 
* In order to override the simple form we have to use `input_field` instead of input but dont forget to add fomr-group class manually
```ruby
<%= f.input_field :tag_list %>
```
* We can create a partial _form and render `form` inside new and edit. Save time

#### Form_tag 
```ruby
simple_form_for :new_session, url: session_path 
```
convert `f.submit_tag` to `f.button :submit`
* Below code changes the name of model from new_session to session[email].  
```ruby
simple_form_for :seesion, as: :new_session, url: session_path 
```
* Beceuase it changes the params and nested it so we should modify the controler. for example it was available session[:emai] and now we have to use nested params. 

## Avator 
```ruby
gem 'carrierwave', '~> 1.0'
```
`spring stop` to clear cash
```ruby
rails generate uploader Avatar
```
Then inside it has configurations. like the storage fog the place you save ec2, and the address you save in public all images 
and also the type of accepting files in line 39 of this file `app/uploaders/avatar_uploader.rb`
```ruby
rails g migration add_image_to_questions image
```
We need to specify the carriedowver with image no w inside quesiton model 
* uploader mount is the file we generated, and this uploader tells the carriedover what should do with this
```ruby
mount_uploader :image, ImageUploader 
```
now inside the console 
`Question.last.image` we see the image is wrpaed with moundet
this command dowload the image for that address 
q.image.download!(url)

gives the path that the image is save 
q.image.path  
* Inside view we have 
<%= image_tag @question.image.path if  @question.image.present? %> 

now inside the controller add :image in params in controler after adding input firell d Â :imag ein view .

### mini_magick
Image we need to resize the image 

gem `mini_magick`
```ruby
brew install imagemagick
```
Inisde image_uploader.rb 
now inside carrierwave  then uncomment minimagick support to access thum function 
so add something like this the eample code is in carreirwave 

```ruby
version :thumb do
    process resize_to_fit: [64,64]
  end
  
  version :small do
    process resize_to_fit: [200,200]
  end
```
 Then after you upload different sizes of images would be uploaded. 
 
 in styling we can have 
 img is child of stylename 
 ```ruby 
 .stylename > img 
 ```
it gives  Question.last(2).first 

it recreate a new version of the images, you can override each other
```ruby
q.image.create_versions!(:medium)
```
## Amazon
* Setting up a bucket on amazon account and get access key and secret access keys then go back to our application. 
```ruby
gem fog 
```
then inside the config/initilizer create setup_fog.rb

```ruby
CarrierWave.configure do |config|
  config.fog_credentials = {
    provider: 'AWS',
    aws_access_key_id: ENV['AWS_ACCESS_KEY_ID'] || '',
    aws_secret_access_key: ENV['AWS_SECRET_ACCESS_KEY'] || '',
    region: 'us-west-2'
  }

  config.fog_directory = 'aa-june-2017' # AWS S3 Bucket Name
  config.fog_public = false
  config.fog_attributes = {
    'Cache-Control' => "max-age=#{{365.day.to_i}}"
  }
end
```
then we specify what bucket we are usung, check your amazon. 
 config.fog_directory = 'aa-june-2017' # AWS S3 Bucket Name
 
 * Now we have to open up config.app_keys.rb 
 and copye paste the 
 ```ruby
ENV['AWS_ACCESS_KEY_ID'] = 'PUT YOUR ACCESS KEY'
ENV['AWS_SECRET_ACCESS_KEY'] = 'PUT YOUR SECRET ACCESS KEY'
```

Now we go to image uloeaded we can specify where to switch where to save image 
```runy
#storage :file
storage :fog 
```
Then it would save inside amazon 
```runy
/public/uploads/*
/config/initializers/app_keys.rb

# See https://help.github.com/articles/ignoring-files for more about ignoring files.
#
# If you find yourself ignoring temporary files generated by your text editor
# or operating system, you probably want to add a global ignore instead:
#   git config --global core.excludesfile '~/.gitignore_global'

# Ignore bundler config.
/.bundle

# Ignore all logfiles and tempfiles.
/log/*
/tmp/*
!/log/.keep
!/tmp/.keep

/node_modules
/yarn-error.log

.byebug_history
```
# State Machine
https://github.com/aasm/aasm
State diagram take one object from one state to another.
there is a `gem aasm`
bunlde update updates all gems. 
check activeRecord in this gem github, 
so we add a column to our table, we want to have state column in question
then run this
```ruby
rails g migration add_asm_to_question aasm_state
```
Always after 
### Cost 
adding index after migration it means we would have something like find me all publish or cancel questions, adding index always give overhead to project everytime you  delete or update index should be updated so indexing has cost. So only add index if you have many querys about that 

Extend iheritent everything as class method but include gives everything as instance. 

now inside question model we have 
DSL : Domain Specific language, it is a ruby code written in a certain way. 
list all states and initial states. Also adding events like. aasm is just a method that gets a block, state is also function to get two arguemnts which the second one is optional, 
they come from these statements with a question at tend 
```ruby
 include AASM
  aasm do
    state(:draft, { initial: true })
    state :published
    state :canceled
    state :answered
    state :closed

    event :publish do
      transitions from: :draft, to: :published
    end

    event :close do
      transitions from: [:published, :answered], to: :closed
    end

    event :cancel do
      transitions from: [:published, :answered], to: :canceled
    end

    event :answer do
      transitions from: :published, to: :answered
    end
  end
```
* To test it go to rails c 

q.draft?
q.published?

to save it we have 
q.publish 
q.save 
then it chagne the state 
also yo can not change state from answered to draft becuse not define in rules 

by adding `winny_transaction` we can avoid getting error and getting a good exception. 

so add it to code
```ruby
  aasm whiny_transitions: false do
    state(:draft, { initial: true })
```
* Also it tells you can move from currnt state to another one like publish 
```ruby
q.may_publish?
```
it loops to all question, but find all first fetch all in memory and then do it interaction 
This one is better and faster 
```ruby
Question.find_each {|q| q.publish!}
```
```ruby
Question.find_each {|q| q.publish! }
Question.where(user: nil).count
Question.where(user: nil).find_each {|q| q.update(user: users.sample) }
```
* So like stackoverflow if a question has has  answered 
* Update with `!` means if it can not succed it returns false otherwise without `!` if not succeed it returns error
### Use state machine inside app
* So we want to list all questions that are not draft or cancel.
* inside question controller 

Question.where(aasm_state: [:published, :closed, :answered]) 

Question.where.not(aasm_state: [:published, :closed, :answered]) 

To create a function from above we define a method like below as self because of `Question.sth` so we define as below  
`def self.nameoffunciotn`
#### Class method  
beause we are calling directly on the class and not the instance of a class so we define self.

* To change the state of a question we would have below code in create answer controller 
```ruby
 @question.answer! 
```
### Create a label in front of question

* Inside view 
```ruby
  <% if question.answered? %>
    <div class='label label-success'>answered</div>
  <% end %>
```

* Also if someone already answerred quesiton and removed it so we change the state when delete happen. 
inside answers controller
```ruby 
if @answer.save
      AnswersMailer.notify_questions_owner(@answer).deliver_now
      @question.answer! if @question.may_answer? # change the state of the question to `answered`
      redirect_to question_path(@question)
    else
```
* Avoid to add more actions than 7 actions in one controller and try to add new controller 
```ruby
rails g controller publishing 
```
we need to nested inside question, because we want the question id. 
```ruby
resources :publishing, only: :create 
```
* Modify routes to access the id of question inside the controller publishing 
```ruby
 resources :questions do
    resources :likes, only: [:create, :destroy]
    resources :answers, only: [:create, :destroy]
    # We can nest routes. When doing so, rails will generate the route prefix
    # with the parent resources in this `/questions/:question_id`

    # Example routes that are generated by the above:
    # /questions/:question_id/answers(.:format)
    # /questions/:question_id/answers/new(.:format)

    # When using a route helper method of a nested route such
    # as question_answers_path (or question_answers_url), you
    # must provide an id or record of the parent resources
    # (e.g. `question_answers_path(@question)`)


    resources :publishings, only: :create
  end
```

* Now inside the controller publish 

```ruby
class PublishingsController < ApplicationController
  before_action :authenticate_user!
  before_action :find_question
  before_action :authorize_user

 def create
    @question.publish!
    redirect_to @question
  end

  private
  def find_question
    @question = Question.find params[:question_id]
  end

  def authorize_user
    head :unauthorized unless can?(:publish, @question)
  end
end
```
* Inside the view 
```ruby
   <%= link_to 'publish', question_publishings_path(@question),
                             method: :post %>
```
-----------

### Thin contorller and Fat models 
Controlers shouldnt do alot of works. Move all methods from controller into models . Instead of having many if conditions in controller try to create another one. 
-------------
# Dynamic Model Form
`First check it is not certain reserved word.`
there would be one to many relation between survery_question and options. eahc survey_question has many options
```ruby
rails g model survey_question user:references title 
rails g model option survey_question:references body 
rails db:migrate
```
* Create a controler to have survey inside admin 
```ruby
rails g controller admin/survey_questions
```
inside the routes we add it
```
 namespace :admin do
    resources :dashboard, only: :index
    resources :survey_questions, only: [:index, :new, :create]
  end
```
* Because the admin controller has some functions to check the authenticity of user and we inhertiate from it

* nested routes form. To change the url method `[:admin, @survey_question]` 
```ruby 
<%= simple_form_for [:admin, @survey_question] do |f| %>
  <%= f.input :title %>
  <%= f.submit class: 'btn btn-primary' %>
<% end %>
```
also remember associated each survey_question to user, to avoid it we should assign optional: true in model. 

### Save the options

inside survery_question model

 belongs_to :user

  has_many :options, dependent: :destroy
  accepts_nested_attributes_for :options
create options at the same time creating survery_question. 

inside the rails c
SurveyQuestion.create(title: 'abc', user: User.last, options_attributes: {"0" => { body: 'option 1'} })

pass sperical attributes and pass a hash awith a key which is new and the value should be another hash  `{ body: 'option 1'}`  with attirbites inside it  option and now it would have tow inset function. Ruby hash should be unique. 

this helps nested the dynamic form that will create optional inside the form 
inside the controller
```ruby
 def new
    @survey_question = SurveyQuestion.new
    # this creates three associated options for the SurveyQuestion all in memory
    # this will help us bested the dynamic form that will eventually create
    # both the survey question and the options in one submission
    3.times { @survey_question.options.build }
  end
  
  def create
    survey_question_params = params
                             .require(:survey_question)
                             .permit(:title, { options_attributes: [:body] })
    @survey_question = SurveyQuestion.new survey_question_params
    @survey_question.user = current_user
    if @survey_question.save
      redirect_to admin_survey_questions_path, notice: 'question created'
    else
      render :new
    end
```

* Now inside the view, added nested controler 
```

<%= simple_form_for [:admin, @survey_question] do |f| %>
  <%= f.input :title %>

  <%= f.simple_fields_for :options do |opt| %>
    <%= opt.input :body %>
  <% end %>

  <%= f.submit class: 'btn btn-primary' %>
<% end %>
```
### Validation inside models
```ruby
 validates :title, presence: true
```
* If you pass invalid so it can reject 
```ruby
accepts_nested_attributes_for :options, reject_if: :all_blank
```
### Add dynamic options 
when you adding or removing 
```ruby
gem "cocoon"
```
so inside application.js add require after jquery, make sure you have jquery3 and jquery_ur 

```javascript
//= require jquery3
//= require vendor/selectize.min
//= require jquery_ujs
//= require cocoon
//= require_tree .
```
* Strong paramsteres Gotcha in github tom and modify create funtion as below 
```ruby
def create
    survey_question_params = params
                             .require(:survey_question)
                             .permit(:title, { options_attributes: [:body,
                                                                    :id,
                                                                    :_destroy]
                                              }
                                    )
```
now inside the admin/views we create a partial field like `Formtastic`

# Geo Location
https://github.com/alexreisner/geocoder
https://github.com/apneadiving/Google-Maps-for-Rails

```ruby
gem 'geocoder'
gem 'gmaps4rails'
gem 'underscore-rails'
```
inside application js modify as 
```ruby
//= require jquery
//= require bootstrap-sprockets
//= require rails-ujs
//= require underscore
//= require gmaps/google
//= require_tree .
```
and put the src files put in app file:

Then add one comulmn to user 
```ruby
rails g migration add_geocoding_to_users longitude:float latitude:float address
```
Inside user model add below code: 
```ruby
geocoded_by :address 
after_validation :geocode
```
now inside the rails console, 
```ruby
u.address = "somewhere" 
u.save
```
then you have lattitude and longtitude inisde the code. 

